<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <link rel="icon" href="data:,">
        <title>value list example</title>
        <style>
            body {
                margin: 0;
                font-family: monospace;
            }
            canvas { width: 100%; height: 100%; }
            input[type=range] { width: 100%; }
            #container { position: relative; }
            #container canvas, #overlay { position: absolute; }
            #overlay { z-index: 1; width: 100%; }
            #overlay div { padding: 5px; }
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>
    <body>
        <div id="container">
            <div id="overlay">
                <button id="export_scene">Download</button>
            </div>
        </div>









        <script type="module">

import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.126.0/build/three.module.js'
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.126.0/examples/jsm/controls/OrbitControls.js'
import { Rhino3dmLoader } from 'https://cdn.jsdelivr.net/npm/three@0.126.0/examples/jsm/loaders/3DMLoader.js'
import rhino3dm from 'https://cdn.jsdelivr.net/npm/rhino3dm@0.15.0-beta/rhino3dm.module.js'
import { GLTFExporter } from 'https://cdn.jsdelivr.net/npm/three@0.126.0/examples/jsm/exporters/GLTFExporter.js';


// initialise 'data' object that will be used by compute()
const data = {
  definition: 'value_list_8.gh',
  inputs: getInputs()
}

// globals
let rhino, doc
rhino3dm().then(async m => {
    rhino = m
    init()
    compute()
})

document.getElementById( 'export_scene' ).addEventListener( 'click', function () {
  console.log("download glb file now..")
  // exportGLTF(scene);
  exportGLTF(tempMesh);
} );




////////////////////////////////////////////////////////////////////////////
//                            HELPER  FUNCTIONS                            //
/////////////////////////////////////////////////////////////////////////////
function exportGLTF( input ) {
  const gltfExporter = new GLTFExporter();
  const options = {
    trs: false,
    onlyVisible: true,
    truncateDrawRange: true,
    binary: true,
    maxTextureSize: 4096 || Infinity // To prevent NaN value
  };
  gltfExporter.parse( input, function ( result ) {
    if ( result instanceof ArrayBuffer ) {
      saveArrayBuffer( result, 'test.glb' );
    } else {
      const output = JSON.stringify( result, null, 2 );
      saveString( output, 'test.gltf' );
    }
  }, options );
}

function saveArrayBuffer( buffer, filename ) {
  save( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );
}

function saveString( text, filename ) {
  save( new Blob( [ text ], { type: 'text/plain' } ), filename );
}

const link = document.createElement( 'a' );
link.style.display = 'none';
document.body.appendChild( link ); // Firefox workaround, see #6594

function save( blob, filename ) {
  link.href = URL.createObjectURL( blob );
  link.download = filename;
  link.click();
  // URL.revokeObjectURL( url ); breaks Firefox...
}



















// more globals
let scene, camera, renderer, controls, tempMesh

/**
 * Sets up the scene, camera, renderer, lights and controls and starts the animation
 */
function init() {
    // Rhino models are z-up, so set this as the default
    THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 0, 1 );

    // create a scene and a camera
    scene = new THREE.Scene()
    scene.background = new THREE.Color(1, 1, 1)
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000)
    camera.position.set(1, -1, 1) // like perspective view

    // very light grey for background, like rhino
    // scene.background = new THREE.Color('whitesmoke')

    // create the renderer and add it to the html
    renderer = new THREE.WebGLRenderer({ antialias: true })
    renderer.setPixelRatio( window.devicePixelRatio )
    renderer.setSize(window.innerWidth, window.innerHeight)
    document.body.appendChild(renderer.domElement)

    // add some controls to orbit the camera
    controls = new OrbitControls(camera, renderer.domElement)

    // // add a directional light
    // const directionalLight = new THREE.DirectionalLight( 0xffffff )
    // directionalLight.intensity = 2
    // scene.add( directionalLight )

    // const ambientLight = new THREE.AmbientLight()
    // scene.add( ambientLight )

    // handle changes in the window size
    window.addEventListener( 'resize', onWindowResize, false )

    animate()
}

/**
 * Call appserver
 */
async function compute() {
  // construct url for GET /solve/definition.gh?name=value(&...)
  const url = new URL('/solve/' + data.definition, window.location.origin)
  // 0 - Y
  // 1 - R
  // 2 - W
  // 3 - SS
  url.searchParams.append("RH_IN:number", 1)
  url.searchParams.append("RH_IN:path", "C:/\Dummy/\jwln0300_2.dxf")

  try {
    const response = await fetch(url)
    if(!response.ok) {
      throw new Error(response.statusText)
    }
    const responseJson = await response.json()
    console.log("responseJson: ", responseJson)
    collectResults_v2(responseJson)
  } catch(error) {
    console.error(error)
  }
}

function _base64ToArrayBuffer(base64) {
  var binary_string = window.atob(base64);
  var len = binary_string.length;
  var bytes = new Uint8Array(len);
  for (var i = 0; i < len; i++) {
    bytes[i] = binary_string.charCodeAt(i);
  }
  return bytes.buffer;
}

function collectResults_v2(responseJson) {
  // clear doc
  if (doc !== undefined)
    doc.delete()

  const values = responseJson.values
  const str = values[0].InnerTree['{0;0;0}'][0].data
  const data = JSON.parse(str)
  const arr = _base64ToArrayBuffer(data)
  doc = rhino.File3dm.fromByteArray(arr)

  if (doc.objects().count < 1) {
    console.error('No rhino objects to load!')
    return
  }

  // set up loader for converting the results to threejs
  const loader = new Rhino3dmLoader()
  loader.setLibraryPath('https://cdn.jsdelivr.net/npm/rhino3dm@0.15.0-beta/')

  // load rhino doc into three.js scene
  loader.parse(arr, function (object) {
    // console.log("loaded: ", object)
    scene.traverse(child => {
      // console.log("scene child: ", child)
      // 1. Scene
      // 2. AmbientLight

      if (child.userData.hasOwnProperty('objectType') && child.userData.objectType === 'File3dm') {        
        scene.remove(child)
      }
    })

    object.traverse(child => {
      // console.log("object child: ", child)
      // 1. Object3D
      // 2. Mesh
      // 3. Line

      // if (child.isMesh) {
      //   const edges = new THREE.EdgesGeometry( child.geometry );
      //   const line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0x000000 } ) )
      //   child.add( line )
      // }

      if (child.isMesh) {
        tempMesh = child
      }

    }, false)

    // zoom to extents
    zoomCameraToSelection(camera, controls, object.children)

    // add object graph from rhino model to three.js scene
    scene.add(object)
  })
}




















/**
 * Gets <input> elements from html and sets handlers
 * (html is generated from the grasshopper definition)
 */
 function getInputs() {
  const inputs = {}
  for (const input of document.getElementsByTagName('input')) {
    switch (input.type) {
      case 'number':
        inputs[input.id] = input.valueAsNumber
        input.onchange = onSliderChange
        break
      case 'range':
        inputs[input.id] = input.valueAsNumber
        input.onmouseup = onSliderChange
        input.ontouchend = onSliderChange
        break
      case 'checkbox':
        inputs[input.id] = input.checked
        input.onclick = onSliderChange
        break
      default:
        break
    }
  }
///////////////////////////////////////////////////////////////////////////
  for (const input of document.getElementsByTagName('select')) {
    inputs[input.id] = input.value
    input.onchange = onSliderChange
  }
///////////////////////////////////////////////////////////////////////////
  return inputs
}

/**
 * Called when a slider value changes in the UI. Collect all of the
 * slider values and call compute to solve for a new scene
 */
 function onSliderChange () {
  // get slider values
  let inputs = {}
  for (const input of document.getElementsByTagName('input')) {
    switch (input.type) {
    case 'number':
      inputs[input.id] = input.valueAsNumber
      break
    case 'range':
      inputs[input.id] = input.valueAsNumber
      break
    case 'checkbox':
      inputs[input.id] = input.checked
      break
    }
  }
///////////////////////////////////////////////////////////////////////////
  for (const input of document.getElementsByTagName('select')) {
    inputs[input.id] = input.value
  }
///////////////////////////////////////////////////////////////////////////
  data.inputs = inputs
  compute()
}

/**
 * The animation loop!
 */
 function animate() {
  requestAnimationFrame( animate )
  controls.update()
  renderer.render(scene, camera)
}


/**
 * Helper function for window resizes (resets the camera pov and renderer size)
  */
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize( window.innerWidth, window.innerHeight )
  animate()
}


/**
 * Helper function that behaves like rhino's "zoom to selection", but for three.js!
 */
function zoomCameraToSelection( camera, controls, selection, fitOffset = 1.2 ) {
  const box = new THREE.Box3();
  for( const object of selection ) {
    if (object.isLight) continue
    box.expandByObject( object );
  }
  const size = box.getSize( new THREE.Vector3() );
  const center = box.getCenter( new THREE.Vector3() );
  
  const maxSize = Math.max( size.x, size.y, size.z );
  const fitHeightDistance = maxSize / ( 2 * Math.atan( Math.PI * camera.fov / 360 ) );
  const fitWidthDistance = fitHeightDistance / camera.aspect;
  const distance = fitOffset * Math.max( fitHeightDistance, fitWidthDistance );
  
  const direction = controls.target.clone()
    .sub( camera.position )
    .normalize()
    .multiplyScalar( distance );
  controls.maxDistance = distance * 10;
  controls.target.copy( center );
  
  camera.near = distance / 100;
  camera.far = distance * 100;
  camera.updateProjectionMatrix();
  camera.position.copy( controls.target ).sub(direction);
  
  controls.update();
}

        </script>




    </body>
</html>
